#define ONE_WAY_LOGIC

using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public enum PathLineType {
    Straight,
    CatmullRomCurve,
}

// Single Node. From which we can create Paths ( or connections )
[System.Serializable]
public class Node {
    public Node(Vector3 pos) { position = pos; }

    public void SetPosition(Vector3 pos) { position = pos; }
    public Vector3 Position { get { return position; } }

    [SerializeField] private Vector3 position;
    [SerializeField] public int ID = -1;
    [HideInInspector] public Node previousNode;
    [HideInInspector] public float heuristicDistance;
    [HideInInspector] public float pathDistance;
    [HideInInspector] public float combinedHeuristic { get { return pathDistance + heuristicDistance; } }
}

// Path is a connection between 2 Nodes. It will have zero cost by default unless specified in inspector. 
// A path can be a oneway too. 
[System.Serializable]
public class Path {
    int iDOfa = -1, IDOfb = -1;
    [SerializeField] [HideInInspector] public Node a, b;
    public int IDOfA {
        get { iDOfa = a.ID; return a.ID; }
        set { iDOfa = value; }
    }
    public int IDOfB {
        get { IDOfb = b.ID; return b.ID; }
        set { IDOfb = value; }
    }
    public int CurrentQueue {
        get { return eq - sQueue; }
    }
    public int Cost {
        get { return CurrentQueue + cost; }
        set { cost = value; }
    }
    private int cost;
    public int sQueue = 0, maxInQueue;
    public int eq = 0;
    public int priori;
    public int Block = 2;//0-block 1-prioritet 2-open

    public Transform tr;

    public int autoGeneratedID;
    [HideInInspector] public bool isOneWay = true;

    public Path(Node aa, Node bb, Transform parent, bool hide = false, int prioritet = 2) {
        priori = prioritet;
        a = aa; b = bb;
        IDOfA = a.ID; IDOfB = b.ID;
        if (!hide) {
            var go = GameObject.CreatePrimitive(PrimitiveType.Cube); tr = go.transform;
            tr.parent = parent;
            go.GetComponent<Renderer>().material = Resources.Load<Material>("street") as Material;
        }
        Visualize();
    }

    void OnDrawGizmos() {
        Gizmos.color = Color.red;
        Gizmos.DrawLine(a.Position, b.Position);
    }
    public void Visualize() {
        maxInQueue = (int)Mathf.Floor(Vector3.Distance(a.Position, b.Position) / 1);
        maxInQueue = maxInQueue < 1 ? 1 : maxInQueue;
        if (tr != null) {
            tr.position = (a.Position + b.Position) / 2f;
            tr.LookAt(b.Position);
            tr.localScale = new Vector3(1, 0.1f, Vector3.Distance(tr.position, b.Position) * 2);
        }
    }
    public int EnterQueue() {
        eq++;
        return eq - 1;
    }
    public void LeaveQueue() {
        ++sQueue;
        //Debug.Log("leave"+sQueue+"id" + autoGeneratedID);
    }
    public bool CanEnter(int prio) {
        if (Block >= prio && maxInQueue > eq - sQueue) {
            return true;
        }
        return false;
    }
}

// A collection of Nodes and Paths ( Connections ).
[System.Serializable]
public class GraphData {
    [SerializeField] public PathLineType lineType;
    [SerializeField] public Color lineColor = Color.yellow;
    [SerializeField] public float nodeSize = 0.5f;
    [SerializeField] public float heightFromTheGround = 0;      // this represents how much offset we create our points from the ground ?
    [SerializeField] public string groundColliderLayerName = "Default";

    public List<Street> AllStreets = new List<Street>();
    public List<Junction> AllJunctions = new List<Junction>();

    public GameObject JunctionPrefab;
    public List<Node> nodes = new List<Node>();
    public List<Node> Spawn = new List<Node>();
    public List<Node> Target = new List<Node>();
    public bool spawn = false;
    public int maxCars = 100;
    public float CarsFreq = 0.1f;

    [HideInInspector] public Dictionary<int, Node> nodesSorted;
    [HideInInspector] public Dictionary<int, Path> pathsSorted;

    public List<Path> Paths {
        get {
            List<Path> paths = new List<Path>();
            foreach (Street s in AllStreets) {
                paths.AddRange(s.paths);
            }
            foreach (Junction s in AllJunctions) {
                paths.AddRange(s.paths);
            }
            return paths;
        }
    }
    //int lpos = 0, ipos = 0;
    //public Path getnext() {
    //    Path p = null;
    //    if (lpos < AllStreets.Count) {
    //        if (ipos < AllStreets[lpos].paths.Count) {
    //            p = AllStreets[lpos].paths[ipos];
    //            ipos++;
    //        } else {
    //            ipos = 0;
    //            lpos++;
    //        }
    //    } else {
    //        int jun = lpos - AllStreets.Count;
    //        if (jun < AllJunctions.Count) {
    //            if (ipos < AllJunctions[jun].paths.Count) {
    //                p = AllJunctions[jun].paths[ipos];
    //                ipos++;
    //            } else {
    //                ipos = 0;
    //                lpos++;
    //            }
    //        } else {
    //            lpos = 0;
    //            ipos = 0;
    //        }
    //    }
    //    return p;
    //}
    public Path FindPath(int aID, int bID) {
        foreach (Street s in AllStreets) {
            Path p = s.paths.Find(item => item.IDOfA == aID && item.IDOfB == bID);
            if (p != null) {
                return p;
            }
        }
        foreach (Junction s in AllJunctions) {
            Path p = s.paths.Find(item => item.IDOfA == aID && item.IDOfB == bID);
            if (p != null) {
                return p;
            }
        }
        return null;
    }

    public GraphData() {
        nodesSorted = new Dictionary<int, Node>();
        pathsSorted = new Dictionary<int, Path>();
    }

    public Node GetNode(int ID) {
        if (nodesSorted.ContainsKey(ID))
            return nodesSorted[ID];
        return null;
    }
    public Path GetPath(int ID) {
        if (pathsSorted.ContainsKey(ID))
            return pathsSorted[ID];
        return null;
    }
    public Path GetPathBetween(int from, int to) {
        ////for (Path pd = getnext(); pd != null; pd = getnext()) {
        foreach (Path pd in Paths) {
            if (
                (pd.IDOfA == from && pd.IDOfB == to)
                || (pd.IDOfB == from && pd.IDOfA == to)
            ) {
                return pd;
            }
        }
        return null;
    }

    public Path GetPathBetween(Node from, Node to) {
        if (from == null | to == null)
            return null;

        return GetPathBetween(from.ID, to.ID);
    }

    public void ReCalculate() {
        nodes.Clear();
        //Paths.Clear();
        Spawn.Clear();
        Target.Clear();
        foreach (Street s in AllStreets) {
            nodes.AddRange(s.nodes);
            //Paths.AddRange(s.paths);
            Spawn.Add(s.spawn);
            Target.Add(s.target);
        }
        //foreach (Junction j in AllJunctions) {
        //paths.AddRange(j.paths);

        //}
        ReGenerateIDs();
    }

    public void Clear() {
        //destroy?
        AllJunctions.Clear();
        AllStreets.Clear();
        //Paths.Clear();
    }
    public void ReGenerateIDs() {
        if (nodes == null)
            return;

        int maxID = nodes.Count;
        for (int i = 0; i < nodes.Count; i++) {
            if (nodes[i].ID > maxID)
                maxID = nodes[i].ID;
        }

        maxID = maxID + 1;
        for (int i = 0; i < nodes.Count; i++) {
            if (nodes[i].ID <= 0)
                nodes[i].ID = maxID++;
        }


        maxID = 0;
        //for (Path pd = getnext(); pd != null; pd = getnext()) {
        foreach (Path pd in Paths) {
            if (pd.autoGeneratedID > maxID)
                maxID = pd.autoGeneratedID;
        }
        maxID = maxID + 1;
        //for (Path pd = getnext(); pd != null; pd = getnext()) {
        foreach (Path pd in Paths) {
            if (pd.autoGeneratedID <= 0)
                pd.autoGeneratedID = maxID++;
        }

        pathsSorted.Clear();
        nodesSorted.Clear();
        for (int i = 0; i < nodes.Count; i++) {
            nodesSorted[nodes[i].ID] = nodes[i];
        }
        //for (Path pd = getnext(); pd != null; pd = getnext()) {
        foreach (Path pd in Paths) {
            pathsSorted[pd.autoGeneratedID] = pd;
        }
    }

}
