#define ONE_WAY_LOGIC

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;
using UnityEditor;

public enum PathLineType {
    Straight,
    CatmullRomCurve,
}

// Single Node. From which we can create Paths ( or connections )
[System.Serializable]
public class Node {
    public Node(Vector3 pos) { position = pos; }

    public void SetPosition(Vector3 pos) { position = pos; }
    public Vector3 Position { get { return position; } }

    [SerializeField] private Vector3 position;
    [SerializeField] public int ID = -1;
    [HideInInspector] public Node previousNode;
    [HideInInspector] public float heuristicDistance;
    [HideInInspector] public float pathDistance;
    [HideInInspector] public float combinedHeuristic { get { return pathDistance + heuristicDistance; } }
}

// Path is a connection between 2 Nodes. It will have zero cost by default unless specified in inspector. 
// A path can be a oneway too. 
[System.Serializable]
public class Path {
    int iDOfa = -1, IDOfb = -1;
    [SerializeField] [HideInInspector] public Node a, b;
    public int IDOfA {
        get { iDOfa = a.ID; return a.ID; }
        set { iDOfa = value; }
    }
    public int IDOfB {
        get { IDOfb = b.ID; return b.ID; }
        set { IDOfb = value; }
    }
    public int CurrentQueue {
        get { return eq - sQueue; }
    }
    public float Cost {
        get { return CurrentQueue + cost; }
        set { cost = value; }
    }
    public float SumaryWaitingTime {
        get { float sum = 0;
            if (QueueTimes == null) {
                QueueTimes = new List<float>();
            }
            foreach (float f in QueueTimes) {
                sum += Time.time- f;
            }
            return sum;
        }
    }

    public Street street;
    private float cost;
    public int sQueue = 0, maxInQueue;
    public int eq = 0;
    public int priori;
    public int Block = 2;//0-block 1-prioritet 2-open
    public Transform tr;
    List<float> QueueTimes = new List<float>();
    
    public int autoGeneratedID;
    [HideInInspector] public bool isOneWay = true;

    public Path(Node aa, Node bb, Transform parent, bool hide = false, int prioritet = 2, Street str = null) {
        QueueTimes = new List<float>();
        street = str;
        priori = prioritet;
        a = aa; b = bb;
        IDOfA = a.ID; IDOfB = b.ID;
        if (!hide) {
            var go = GameObject.CreatePrimitive(PrimitiveType.Cube); tr = go.transform;
            tr.parent = parent;
            go.GetComponent<Renderer>().material = Resources.Load<Material>("street") as Material;
        }
        Visualize();
    }

    public void Visualize() {
        cost = Vector3.Distance(a.Position, b.Position);
        maxInQueue = (int)Mathf.Floor(cost - 0.5f);
        maxInQueue = maxInQueue < 1 ? 1 : maxInQueue;
        if (tr != null) {
            tr.position = (a.Position + b.Position) / 2f;
            tr.LookAt(b.Position);
            tr.localScale = new Vector3(1, 0.1f, Vector3.Distance(tr.position, b.Position) * 2);
        }
    }
    public int EnterQueue() {
        eq++;
        if (QueueTimes==null) {
            QueueTimes = new List<float>();
        }
        QueueTimes.Add(Time.time);
        return eq - 1;
    }
    public void LeaveQueue() {
        QueueTimes.RemoveAt(0);
        ++sQueue;
    }
    public bool CanEnter(int prio) {
        if (Block >= prio && maxInQueue > eq - sQueue) {
            return true;
        }
        return false;
    }
}

// A collection of Nodes and Paths ( Connections ).
[System.Serializable]
public class GraphData {
    [SerializeField] public PathLineType lineType;
    [SerializeField] public Color lineColor = Color.yellow;
    [SerializeField] public float nodeSize = 0.5f;
    [SerializeField] public float heightFromTheGround = 0;      // this represents how much offset we create our points from the ground ?
    [SerializeField] public string groundColliderLayerName = "Default";

    public List<Street> AllStreets = new List<Street>();
    public List<Junction> AllJunctions = new List<Junction>();

    public GameObject JunctionPrefab;
    public List<Node> nodes = new List<Node>();
    public List<Node> center = new List<Node>();
    public bool spawn = false;

    [HideInInspector] public Dictionary<int, Node> nodesSorted;
    [HideInInspector] public Dictionary<int, Path> pathsSorted;

    public List<Path> Paths {
        get {
            List<Path> paths = new List<Path>();
            foreach (Street s in AllStreets) {
                paths.AddRange(s.paths);
            }
            foreach (Junction s in AllJunctions) {
                paths.AddRange(s.paths);
            }
            return paths;
        }
    }

    public Path FindPath(int aID, int bID) {
        foreach (Street s in AllStreets) {
            Path p = s.paths.Find(item => item.IDOfA == aID && item.IDOfB == bID);
            if (p != null) {
                return p;
            }
        }
        foreach (Junction s in AllJunctions) {
            Path p = s.paths.Find(item => item.IDOfA == aID && item.IDOfB == bID);
            if (p != null) {
                return p;
            }
        }
        return null;
    }

    public void loadTimers() {
        string destination = Application.persistentDataPath + "/save2.dat";
        FileStream file;

        if (File.Exists(destination)) file = File.OpenRead(destination);
        else {
            Debug.Log("File not found");
            return;
        }
        BinaryFormatter bf = new BinaryFormatter();

        float[][] master = (float[][])bf.Deserialize(file);
        if (AllJunctions.Count != master.Length) {
            return;
        }
        for (int i = 0; i < AllJunctions.Count; i++) {
            AllJunctions[i].Timers = master[i];
        }
        file.Close();
        Debug.Log("File loaded");
    }
    public void saveTimers() {
        string destination = Application.persistentDataPath + "/save2.dat";
        FileStream file;

        if (File.Exists(destination)) {
            File.Delete(destination);
        }

        BinaryFormatter bf = new BinaryFormatter();
        float[][] master = new float[AllJunctions.Count][];
        for (int i = 0; i < AllJunctions.Count; i++) {
            master[i] = AllJunctions[i].Timers;
        }
        file = File.Create(destination);
        bf.Serialize(file, master);
        file.Close();
        Debug.Log("File saved");
    }

    public GraphData() {
        nodesSorted = new Dictionary<int, Node>();
        pathsSorted = new Dictionary<int, Path>();
    }

    public Node GetNode(int ID) {
        if (nodesSorted.ContainsKey(ID))
            return nodesSorted[ID];
        return null;
    }
    public Path GetPath(int ID) {
        if (pathsSorted.ContainsKey(ID))
            return pathsSorted[ID];
        return null;
    }
    public Path GetPathBetween(int from, int to) {
        ////for (Path pd = getnext(); pd != null; pd = getnext()) {
        foreach (Path pd in Paths) {
            if (
                (pd.IDOfA == from && pd.IDOfB == to)
                || (pd.IDOfB == from && pd.IDOfA == to)
            ) {
                return pd;
            }
        }
        return null;
    }

    public Path GetPathBetween(Node from, Node to) {
        if (from == null | to == null)
            return null;

        return GetPathBetween(from.ID, to.ID);
    }

    public void ReCalculate() {
        nodes.Clear();
        //Paths.Clear();
        center.Clear();
        foreach (Street s in AllStreets) {
            nodes.AddRange(s.nodes);
            //Paths.AddRange(s.paths);
            center.Add(s.center);
        }
        //foreach (Junction j in AllJunctions) {
        //paths.AddRange(j.paths);

        //}
        ReGenerateIDs();
    }

    public void Clear() {
        //destroy?
        AllJunctions.Clear();
        AllStreets.Clear();
        //Paths.Clear();
    }
    public void ReGenerateIDs() {
        if (nodes == null)
            return;

        int maxID = nodes.Count;
        for (int i = 0; i < nodes.Count; i++) {
            if (nodes[i].ID > maxID)
                maxID = nodes[i].ID;
        }

        maxID = maxID + 1;
        for (int i = 0; i < nodes.Count; i++) {
            if (nodes[i].ID <= 0)
                nodes[i].ID = maxID++;
        }


        maxID = 0;
        foreach (Path pd in Paths) {
            if (pd.autoGeneratedID > maxID)
                maxID = pd.autoGeneratedID;
        }
        maxID = maxID + 1;
        foreach (Path pd in Paths) {
            if (pd.autoGeneratedID <= 0)
                pd.autoGeneratedID = maxID++;
        }

        pathsSorted.Clear();
        nodesSorted.Clear();
        for (int i = 0; i < nodes.Count; i++) {
            nodesSorted[nodes[i].ID] = nodes[i];
        }
        foreach (Path pd in Paths) {
            pathsSorted[pd.autoGeneratedID] = pd;
        }
    }

}
