#define ONE_WAY_LOGIC

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;
using UnityEditor;

public enum PathLineType {
    Straight,
    CatmullRomCurve,
}

// Single Node. From which we can create Paths ( or connections )
[System.Serializable]
public class Node {
    public Node(Vector3 pos) { position = pos; }

    public void SetPosition(Vector3 pos) { position = pos; }
    public Vector3 Position { get { return position; } }

    [SerializeField] private Vector3 position;
    [SerializeField] public int ID = -1;
    [HideInInspector] public Node previousNode;
    [HideInInspector] public float heuristicDistance;
    [HideInInspector] public float pathDistance;
    [HideInInspector] public float combinedHeuristic { get { return pathDistance + heuristicDistance; } }
}

// Path is a connection between 2 Nodes. It will have zero cost by default unless specified in inspector. 
// A path can be a oneway too. 
[System.Serializable]
public class Path {
    [SerializeField] [HideInInspector] public Node a, b;
    public int IDOfA {
        get { return a.ID; }
    }
    public int IDOfB {
        get { return b.ID; }
    }
    public int CurrentQueue {
        get { return eq - sQueue; }
    }
    public float Cost {
        get { return CurrentQueue + cost; }
        //set { cost = value; }
    }
    public float SumaryWaitingTime {
        get {
            float sum = 0;
            if (QueueTimes == null) {
                QueueTimes = new List<float>();
            }
            foreach (float f in QueueTimes) {
                sum += Time.time - f;
            }
            return sum;
        }
    }

    public Street street;
    [SerializeField] float cost;
    public int sQueue = 0, maxInQueue;
    public int eq = 0;
    public int priori;
    public int Block = 2;//0-block 1-prioritet 2-open
    public int hide;
    public Transform tr;
    List<float> QueueTimes = new List<float>();

    public int autoGeneratedID;
    [HideInInspector] public bool isOneWay = true;

    public Path(Node aa, Node bb, Transform parent, int hid = 0, int prioritet = 2, Street str = null) {
        QueueTimes = new List<float>();
        hide = hid;
        street = str;
        priori = prioritet;
        a = aa; b = bb;
        if (hide < 2) {
            var go = GameObject.CreatePrimitive(PrimitiveType.Cube); tr = go.transform;
            tr.parent = parent;
            go.GetComponent<Renderer>().material = Resources.Load<Material>("street") as Material;
        }
        Visualize();
    }

    public void Visualize() {
        cost = hide == 0 ? Vector3.Distance(a.Position, b.Position) : 0;
        maxInQueue = (int)Mathf.Floor(cost - 0.5f);
        maxInQueue = maxInQueue < 1 ? 1 : maxInQueue;
        if (tr != null) {
            tr.position = (a.Position + b.Position) / 2f;
            tr.LookAt(b.Position);
            tr.localScale = new Vector3(0.6f, 0.1f, Vector3.Distance(tr.position, b.Position) * 2);
        }
    }
    public int EnterQueue() {
        eq++;
        if (QueueTimes == null) {
            QueueTimes = new List<float>();
        }
        QueueTimes.Add(Time.time);
        return eq - 1;
    }
    public void LeaveQueue() {
        QueueTimes.RemoveAt(0);
        ++sQueue;
    }
    public bool CanEnter(int prio) {
        if (Block >= prio && maxInQueue > eq - sQueue) {
            return true;
        }
        return false;
    }
}

// A collection of Nodes and Paths ( Connections ).
[System.Serializable]
public class GraphData {
    public PathLineType lineType;
    public float heightFromTheGround = 0;      // this represents how much offset we create our points from the ground ?
    public string groundColliderLayerName = "Default";

    [HideInInspector] public List<Street> AllStreets = new List<Street>();
    [HideInInspector] public List<Junction> AllJunctions = new List<Junction>();

    [HideInInspector] public List<Node> nodes = new List<Node>();
    [HideInInspector] public List<Node> centers = new List<Node>();
    [HideInInspector] public List<Path> paths = new List<Path>();

    [HideInInspector] public Dictionary<Vector2Int, int> pathsByNodes = new Dictionary<Vector2Int, int>();


    public void loadTimers() {
        string destination = Application.persistentDataPath + "/save2.dat";
        FileStream file;

        if (File.Exists(destination)) file = File.OpenRead(destination);
        else {
            Debug.Log("File not found");
            return;
        }
        BinaryFormatter bf = new BinaryFormatter();

        float[][] master = (float[][])bf.Deserialize(file);
        if (AllJunctions.Count != master.Length) {
            return;
        }
        for (int i = 0; i < AllJunctions.Count; i++) {
            AllJunctions[i].Timers = master[i];
        }
        file.Close();
        Debug.Log("File loaded");
    }
    public void saveTimers() {
        string destination = Application.persistentDataPath + "/save2.dat";
        FileStream file;

        if (File.Exists(destination)) {
            File.Delete(destination);
        }

        BinaryFormatter bf = new BinaryFormatter();
        float[][] master = new float[AllJunctions.Count][];
        for (int i = 0; i < AllJunctions.Count; i++) {
            master[i] = AllJunctions[i].Timers;
        }
        file = File.Create(destination);
        bf.Serialize(file, master);
        file.Close();
        Debug.Log("File saved");
    }


    public Path GetPathBetween(int from, int to) {
        return paths[pathsByNodes[new Vector2Int(from, to)]];
    }

    public Path GetPathBetween(Node from, Node to) {
        return GetPathBetween(from.ID, to.ID);
    }

    public void Clear() {
        AllJunctions.Clear();
        AllStreets.Clear();
        paths.Clear();
        nodes.Clear();
    }
    public void ReGenerateIDs() {
        nodes.Clear();
        centers.Clear();
        paths.Clear();
        foreach (Street s in AllStreets) {
            nodes.AddRange(s.nodes);
            //nodes.Add(s.center);
            centers.Add(s.center);
            paths.AddRange(s.paths);
        }

        foreach (Junction j in AllJunctions) { paths.AddRange(j.paths); }
        for (int i = 0; i < nodes.Count; i++) { nodes[i].ID = i; }
        for (int i = 0; i < paths.Count; i++) { paths[i].autoGeneratedID = i; }

        pathsByNodes = new Dictionary<Vector2Int, int>();
        for (int i = 0; i < paths.Count; i++) {
            pathsByNodes.Add(new Vector2Int(paths[i].IDOfA, paths[i].IDOfB), i);
        }
    }

}
