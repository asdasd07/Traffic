using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;
using UnityEditor;
using System;

public enum PathLineType {
    Straight,
    CatmullRomCurve,
}

// A collection of Nodes and Paths ( Connections ).
[System.Serializable]
public class GraphData {
    public PathLineType lineType;
    public float heightFromTheGround = 0;      // this represents how much offset we create our points from the ground ?

    [HideInInspector] public List<Street> AllStreets = new List<Street>();
    [HideInInspector] public List<Junction> AllJunctions = new List<Junction>();

    [HideInInspector] public List<Node> nodes = new List<Node>();
    [HideInInspector] public List<Node> centers = new List<Node>();
    [HideInInspector] public List<Path> paths = new List<Path>();

    [HideInInspector] public Dictionary<Vector2Int, int> pathsByNodes = new Dictionary<Vector2Int, int>();

    [Serializable]
    struct SavingStructure {
        public float[][] Timers;
        public int[][] eqCounter;
    }
    public void LoadTimers() {
        string destination = Application.persistentDataPath + "/save2.dat";
        FileStream file;

        if (File.Exists(destination)) file = File.OpenRead(destination);
        else {
            Debug.Log("File not found");
            return;
        }
        BinaryFormatter bf = new BinaryFormatter();
        SavingStructure sav = (SavingStructure)bf.Deserialize(file);
        float[][] Timers = sav.Timers;
        int[][] eqCounter = sav.eqCounter;

        if (AllJunctions.Count != Timers.Length) {
            return;
        }
        for (int i = 0; i < AllJunctions.Count; i++) {
            AllJunctions[i].timers = Timers[i];
            if (AllJunctions[i].paths.Count == eqCounter[i].Length) {
                for (int j = 0; j < AllJunctions[i].paths.Count; j++) {
                    AllJunctions[i].paths[j].entireQueue = eqCounter[i][j];
                }
            }
        }
        file.Close();
        Debug.Log("File loaded");
    }
    public void SaveTimers() {
        string destination = Application.persistentDataPath + "/save2.dat";
        FileStream file;

        if (File.Exists(destination)) {
            File.Delete(destination);
        }
        BinaryFormatter bf = new BinaryFormatter();
        float[][] Timers = new float[AllJunctions.Count][];
        int[][] eqCounter = new int[AllJunctions.Count][];
        for (int i = 0; i < AllJunctions.Count; i++) {
            Timers[i] = AllJunctions[i].timers;
            eqCounter[i] = new int[AllJunctions[i].paths.Count];
            for (int j = 0; j < AllJunctions[i].paths.Count; j++) {
                eqCounter[i][j] = AllJunctions[i].paths[j].entireQueue;
            }
        }
        SavingStructure sav = new SavingStructure {
            Timers = Timers,
            eqCounter = eqCounter
        };
        file = File.Create(destination);
        bf.Serialize(file, sav);
        file.Close();
        Debug.Log("File saved");
    }


    public Path GetPathBetween(int from, int to) {
        return paths[pathsByNodes[new Vector2Int(from, to)]];
    }

    public Path GetPathBetween(Node from, Node to) {
        return GetPathBetween(from.ID, to.ID);
    }

    public void Clear() {
        AllJunctions.Clear();
        AllStreets.Clear();
        paths.Clear();
        nodes.Clear();
    }
    public void ReGenerateIDs() {
        nodes.Clear();
        centers.Clear();
        paths.Clear();
        foreach (Street s in AllStreets) {
            nodes.AddRange(s.nodes);
            //nodes.Add(s.center);
            centers.Add(s.center);
            paths.AddRange(s.paths);
        }

        foreach (Junction j in AllJunctions) { paths.AddRange(j.paths); }
        for (int i = 0; i < nodes.Count; i++) { nodes[i].ID = i; }
        for (int i = 0; i < paths.Count; i++) { paths[i].autoGeneratedID = i; }

        pathsByNodes = new Dictionary<Vector2Int, int>();
        for (int i = 0; i < paths.Count; i++) {
            pathsByNodes.Add(new Vector2Int(paths[i].IDOfA, paths[i].IDOfB), i);
        }
    }

}
