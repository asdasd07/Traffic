using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Typ wyliczeniowy, służący do określenia czy ścieżka jest zablokowana, otwarta, czy dla pojazdów z pierszeństwem
/// </summary>
public enum BlockType {
    Blocked = 0,
    Priority = 1,
    Open = 2
};
/// <summary>
/// Typ wyliczeniowy, służący do określenia czy ścieżka ma być widoczna, widoczna bez GUI, czy ukryta
/// </summary>
public enum HidePath {
    Shown = 0,
    Internal = 1,
    Hiden = 2
};

/// QPathFinder modified
/// Path is a connection between 2 Nodes.
/// <summary>
/// Ścieżka łącząca dwa wierzchołki grafu
/// </summary>
/// 
[System.Serializable]
public class Path {
    /// <summary>
    /// Przechowuje pierwszy wierzchołek ścieżki
    /// </summary>
    [SerializeField] Node a;
    /// <summary>
    /// Przechowuje drugi wierzchołek ścieżki
    /// </summary>
    [SerializeField] Node b;
    /// <summary>
    /// Przechowuje koszt przebycia ścieżki
    /// </summary>
    [SerializeField] float cost;
    /// <summary>
    /// Przechowuje listę czasów, w których pojazd wjechał na ścieżkę
    /// </summary>
    [SerializeField] List<float> queueTimes;
    /// <summary>
    /// Przechowuje liczbę pojazdów, które opuściły ścieżkę
    /// </summary>
    public int leftQueue = 0;
    /// <summary>
    /// Przechowuje liczbę pojazdów, które wjechały na ścieżkę
    /// </summary>
    public int entireQueue = 0;
    /// <summary>
    /// Przechowuje maksymalną ilość pojazdów mogących jednocześnie przebywać na ścieżce.
    /// </summary>
    public int maxInQueue;
    /// <summary>
    /// Przechowuje identyfikator ścieżki
    /// </summary>
    public int autoGeneratedID;
    /// <summary>
    /// Oznacza priorytet pojazdów znajdujących się na ścieżce
    /// </summary>
    public BlockType priority;
    /// <summary>
    /// Oznacza typ blokady ścieżki
    /// </summary>
    public BlockType block = BlockType.Open;
    /// <summary>
    /// Oznacza typ ukrycia ścieżki
    /// </summary>
    [SerializeField] public HidePath hide;
    /// <summary>
    /// Przechowuje referencje do ulicy, o ile do jakiejś należy
    /// </summary>
    [SerializeField] public Street street;
    /// <summary>
    /// Przechowuje referencje do komponentu Transform, o ile go posiada
    /// </summary>
    [HideInInspector] public Transform transform;

    /// <summary>
    /// Zwraca identyfikator pierwszego wierzchołka
    /// </summary>
    public int IDOfA {
        get { return a == null ? -1 : a.ID; }
    }

    /// <summary>
    /// Zwraca identyfikator drugiego wierzchołka
    /// </summary>
    public int IDOfB {
        get { return b == null ? -1 : b.ID; }
    }

    /// <summary>
    /// Zwraca pozycje pierwszego wierzchołka
    /// </summary>
    public Vector3 PosOfA {
        get { return a == null ? Vector3.zero : a.position; }
    }

    /// <summary>
    /// Zwraca pozycje drugiego wierzchołka
    /// </summary>
    public Vector3 PosOfB {
        get { return b == null ? Vector3.zero : b.position; }
    }

    /// <summary>
    /// Zwraca aktualną ilość pojazdów w kolejce
    /// </summary>
    public int CurrentQueue {
        get { return entireQueue - leftQueue; }
    }

    /// <summary>
    /// Zwraca aktualny koszt przejazdu przez ścieżkę
    /// </summary>
    public float Cost {
        get { return CurrentQueue + cost; }
    }

    /// <summary>
    /// Zwraca sumę czasu jaką czekają pojazdy w kolejce
    /// </summary>
    public float SumaryWaitingTime {
        get {
            float sum = 0;
            foreach (float f in queueTimes) {
                sum += Time.time - f;
            }
            return sum;
        }
    }
    /// <summary>
    /// Konstruktor
    /// </summary>
    /// <param name="A">Pierwszy wierzchołek</param>
    /// <param name="B">Drugi wierzchołek</param>
    /// <param name="Parent">Rodzic obiektu</param>
    /// <param name="Hide">Oznaczenie ukrycia</param>
    /// <param name="Prioritet">Oznaczenie priorytetu</param>
    public Path(Node A, Node B, Transform Parent, HidePath Hide = HidePath.Shown, BlockType Prioritet = BlockType.Open) {
        queueTimes = new List<float>();
        hide = Hide;
        street = Parent.GetComponent<Street>();
        priority = Prioritet;
        a = A; b = B;
        if (this.hide < HidePath.Hiden) {
            var go = GameObject.CreatePrimitive(PrimitiveType.Cube);
            go.GetComponent<BoxCollider>().size = new Vector3(1.4f, 1f, 1f);
            transform = go.transform;
            transform.parent = Parent;
            go.GetComponent<Renderer>().material = Resources.Load<Material>("street") as Material;
        }
        Visualize();
    }
    /// <summary>
    /// Metoda odpowiada za wizualne przedstawienie obiektu
    /// </summary>
    public void Visualize() {
        cost = hide == HidePath.Shown ? Vector3.Distance(PosOfA, PosOfB) : 0;
        maxInQueue = (int)Mathf.Floor(Vector3.Distance(PosOfA, PosOfB) - 0.5f);
        maxInQueue = maxInQueue < 1 ? 1 :  maxInQueue;
        maxInQueue = hide != HidePath.Shown && maxInQueue > 2 ? 2 : maxInQueue;
        if (transform != null) {
            transform.position = (PosOfA + PosOfB) / 2f;
            transform.LookAt(PosOfB);
            transform.localScale = new Vector3(0.6f, 0.1f, Vector3.Distance(transform.position, PosOfB) * 2);
        }
    }
    /// <summary>
    /// Metoda odpowiada czy pojazd z innej ścieżki, może wjechać na tą
    /// </summary>
    /// <param name="Priority">Priorytet ścieżki pytającego pojazdu</param>
    /// <returns>Zwraca prawdę, jeżeli pojazd może wjechać</returns>
    public bool CanEnter(BlockType Priority) {
        if (block >= Priority && maxInQueue > entireQueue - leftQueue) {
            return true;
        }
        return false;
    }
    /// <summary>
    /// Metoda odpowiada za dodanie pojazdu do kolejki
    /// </summary>
    /// <returns>Zwraca numer pojazdu w kolejce</returns>
    public int EnterQueue() {
        entireQueue++;
        queueTimes.Add(Time.time);
        return entireQueue - 1;
    }
    /// <summary>
    /// Metoda odpowiada za usunięcie pojazdu z kolejki
    /// </summary>
    public void LeaveQueue() {
        queueTimes.RemoveAt(0);
        ++leftQueue;
    }
}