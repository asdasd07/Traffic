using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// Path is a connection between 2 Nodes. It will have zero cost by default unless specified in inspector. 
// A path can be a oneway too. 
[System.Serializable]
public class Path {
    [SerializeField] [HideInInspector] public Node a, b;
    public int IDOfA {
        get { return a.ID; }
    }
    public int IDOfB {
        get { return b.ID; }
    }
    public int CurrentQueue {
        get { return eq - sQueue; }
    }
    public float Cost {
        get { return CurrentQueue + cost; }
    }
    public float SumaryWaitingTime {
        get {
            float sum = 0;
            if (QueueTimes == null) {
                QueueTimes = new List<float>();
            }
            foreach (float f in QueueTimes) {
                sum += Time.time - f;
            }
            return sum;
        }
    }
    public Street street;
    [SerializeField] float cost;
    public int sQueue = 0, maxInQueue;
    public int eq = 0;
    public int priori;
    public int Block = 2;//0-block 1-prioritet 2-open
    public int hide;
    public Transform tr;
    List<float> QueueTimes = new List<float>();

    public int autoGeneratedID;
    [HideInInspector] public bool isOneWay = true;

    public Path(Node aa, Node bb, Transform parent, int hid = 0, int prioritet = 2, Street str = null) {
        QueueTimes = new List<float>();
        hide = hid;
        street = str;
        priori = prioritet;
        a = aa; b = bb;
        if (hide < 2) {
            var go = GameObject.CreatePrimitive(PrimitiveType.Cube); tr = go.transform;
            tr.parent = parent;
            go.GetComponent<Renderer>().material = Resources.Load<Material>("street") as Material;
        }
        Visualize();
    }

    public void Visualize() {
        cost = hide == 0 ? Vector3.Distance(a.Position, b.Position) : 0;
        maxInQueue = (int)Mathf.Floor(cost - 0.5f);
        maxInQueue = maxInQueue < 1 ? 1 : maxInQueue;
        if (tr != null) {
            tr.position = (a.Position + b.Position) / 2f;
            tr.LookAt(b.Position);
            tr.localScale = new Vector3(0.6f, 0.1f, Vector3.Distance(tr.position, b.Position) * 2);
        }
    }
    public int EnterQueue() {
        eq++;
        if (QueueTimes == null) {
            QueueTimes = new List<float>();
        }
        QueueTimes.Add(Time.time);
        return eq - 1;
    }
    public void LeaveQueue() {
        QueueTimes.RemoveAt(0);
        ++sQueue;
    }
    public bool CanEnter(int prio) {
        if (Block >= prio && maxInQueue > eq - sQueue) {
            return true;
        }
        return false;
    }
}